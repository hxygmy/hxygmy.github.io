<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.hxygmy.site","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="插桩技术详解，以DynamoRIO和Intel PIN为例">
<meta property="og:type" content="article">
<meta property="og:title" content="程序插桩（Instrumentation）技术">
<meta property="og:url" content="http://www.hxygmy.site/2024/05/01/005%20%E7%A8%8B%E5%BA%8F%E6%8F%92%E6%A1%A9%EF%BC%88Instrumentation%EF%BC%89%E6%8A%80%E6%9C%AF/index.html">
<meta property="og:site_name" content="正经人谁写技术博客啊">
<meta property="og:description" content="插桩技术详解，以DynamoRIO和Intel PIN为例">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/hxygmy/pgo/main/img/202405210826617.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hxygmy/pgo/main/img/202405210826777.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hxygmy/pgo/main/img/202405210826115.png">
<meta property="og:image" content="https://raw.githubusercontent.com/hxygmy/pgo/main/img/202405210826849.png">
<meta property="article:published_time" content="2024-04-30T17:34:12.000Z">
<meta property="article:modified_time" content="2024-05-22T03:49:35.577Z">
<meta property="article:author" content="何晓宇">
<meta property="article:tag" content="Paper">
<meta property="article:tag" content="系统优化">
<meta property="article:tag" content="Instrumentation">
<meta property="article:tag" content="DynamoRIO">
<meta property="article:tag" content="Intel Pin">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/hxygmy/pgo/main/img/202405210826617.png">

<link rel="canonical" href="http://www.hxygmy.site/2024/05/01/005%20%E7%A8%8B%E5%BA%8F%E6%8F%92%E6%A1%A9%EF%BC%88Instrumentation%EF%BC%89%E6%8A%80%E6%9C%AF/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>程序插桩（Instrumentation）技术 | 正经人谁写技术博客啊</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">正经人谁写技术博客啊</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">何晓宇的技术博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.hxygmy.site/2024/05/01/005%20%E7%A8%8B%E5%BA%8F%E6%8F%92%E6%A1%A9%EF%BC%88Instrumentation%EF%BC%89%E6%8A%80%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.ico">
      <meta itemprop="name" content="何晓宇">
      <meta itemprop="description" content="技术博客，系统优化，编译器，指令集">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="正经人谁写技术博客啊">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          程序插桩（Instrumentation）技术
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-01 01:34:12" itemprop="dateCreated datePublished" datetime="2024-05-01T01:34:12+08:00">2024-05-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-22 11:49:35" itemprop="dateModified" datetime="2024-05-22T11:49:35+08:00">2024-05-22</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>25 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <center>插桩技术详解，以DynamoRIO和Intel PIN为例</center>

<span id="more"></span>

<h3 id="一、什么是插桩"><a href="#一、什么是插桩" class="headerlink" title="一、什么是插桩"></a>一、什么是插桩</h3><p>程序插桩（Instrumentation）是一种软件工程技术，它涉及在不改变程序原有逻辑的前提下，向程序代码中添加额外的代码片段，这些额外的代码的主要目的是收集程序运行时的详细信息，以便于分析、测试、调试或性能监控。</p>
<p>把程序本身比作一位做菜的厨师，插桩类似于该厨师的学徒或助手，师父做菜的时候，在不影响师父做菜的流程的情况下，在某些点记录做菜流程的数据，比如用了多少调料，烹饪的时间等。</p>
<h3 id="二、为什么需要插桩"><a href="#二、为什么需要插桩" class="headerlink" title="二、为什么需要插桩"></a>二、为什么需要插桩</h3><p>插桩是监控程序行为的一种工具，通过插桩技术可以更好地对程序的行为进行监控分析。</p>
<p>对于程序优化来说，插桩技术可以辅助分析代码覆盖率、热点代码片段，甚至发现内存泄漏等安全漏洞，是一种非常有效的辅助手段。</p>
<p>此外，插桩技术还可以进行性能分析、安全审计、程序质量评估等工作。</p>
<h3 id="三、插桩的分类"><a href="#三、插桩的分类" class="headerlink" title="三、插桩的分类"></a>三、插桩的分类</h3><blockquote>
<ul>
<li><strong>手动</strong>（Manual）：是由程序设计者加入指令，在执行时计算相关信息。</li>
<li><strong>源代码层级自动处理</strong>（Automatic source level）：依照插桩政策，利用自动化工具自动在源代码中加入插桩。</li>
<li><strong>中间语言</strong>（Intermediate language）：在汇编语言或是字节码（Bytecode）中加入针对多种高级语言的插桩，要避免无符号二进制偏移重写问题。</li>
<li><strong>编译器协助</strong>（Compiler assisted）：像gprof和Quantify都是这类的例子，像用*gcc -pg …<em>可以使用gprof，用</em>quantify g++ …*可以使用Quantify。</li>
<li><strong>二进制翻译</strong>（Binary translation）：此工具在编译好的可执行程序(executable)中加入插桩。</li>
<li><strong>执行时插桩</strong>（Runtime instrumentation）：代码直接在执行前修改，工具可以完成的监控及控制程序的执行。</li>
<li><strong>执行时注入</strong>（Runtime injection）：修改程度比执行时插桩要小，在运行时修改代码，以便跳转到注入的代码入口。</li>
</ul>
</blockquote>
<p>(<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90">性能分析 - 维基百科</a>)</p>
<p>其中</p>
<p>Manual、Automatic source level、Intermediate language、Compiler assisted属于<strong>静态插桩</strong></p>
<p><strong>静态插桩</strong>是指在源代码编译成为可执行程序期间一并进行编译的插桩。然而，静态插桩也包括指令级别的插桩，即在某条机器指令的前后进行插桩。这样的实现可以通过编译器插件对编译器进行扩展，从而在编译过程中的某个阶段介入对中间表示（IR）进行修改，或者说在编译过程中的生成汇编代码（Compilation）后、链接（Linking）之前对汇编代码进行修改。（Preprocessing -&gt; Compilation -&gt; Assembly -&gt; Linking）</p>
<p>Runtime instrumentation、Runtime injection属于<strong>动态插桩</strong></p>
<p>动态插桩指的是在程序运行时进行的插桩。</p>
<p>Binary translation包含动态二进制翻译和静态二进制翻译，分别属于静态插桩和动态插桩</p>
<p>根据插桩的级别，插桩可以分为<strong>源代码级别</strong>的插桩和<strong>二进制代码级别</strong>的插桩。然而，现有的插桩工具，如Intel Pin，实际上提供了更多级别的插桩，如Basic Block级别的插桩。</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">⭐提出问题：</span><br><span class="line">什么是二进制翻译？</span><br><span class="line">二进制翻译为什么可以协助插桩的实现？</span><br><span class="line">二进制翻译和二进制插桩有什么关系？</span><br><span class="line"></span><br><span class="line">解决思路：</span><br><span class="line">整体看的差不多了再回来解决这个问题，优先推进二进制插桩的学习。</span><br><span class="line"></span><br><span class="line"><span class="number">20240512</span>更新：</span><br><span class="line">二进制翻译由于涉及到对指令的重写，所以在这个过程中可以对程序进行插桩。</span><br><span class="line">我已经忘记了原来是为什么不理解，甚至是完全无法联系起来这一点的，大概是有了相应的知识之后就不理解“不理解”这件事了。</span><br></pre></td></tr></table></figure>



<h4 id="静态插桩和动态插桩的对比"><a href="#静态插桩和动态插桩的对比" class="headerlink" title="静态插桩和动态插桩的对比"></a>静态插桩和动态插桩的对比</h4><table>
<thead>
<tr>
<th align="center">静态插桩</th>
<th align="center">动态插桩</th>
</tr>
</thead>
<tbody><tr>
<td align="center">程序运行之前插桩</td>
<td align="center">程序运行时插桩</td>
</tr>
<tr>
<td align="center">无法实时更改、适应</td>
<td align="center">可以根据程序行为即时调整策略</td>
</tr>
</tbody></table>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">心得<span class="number">20240501</span>:</span><br><span class="line"></span><br><span class="line">刨根问底是一个好的行为，但是同时也不像看起来那样简单。看似懂了的问题实际上很可能欠考虑。</span><br><span class="line">在学习过程中，进度慢和学不会其实都是小问题，真正难以解决的问题是，我不知道我不会什么。</span><br></pre></td></tr></table></figure>



<h3 id="四、DynamoRIO"><a href="#四、DynamoRIO" class="headerlink" title="四、DynamoRIO"></a>四、DynamoRIO</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>一个运行时代码操作系统。随着软件技术的发展，静态优化手段不太能跟上对软件中频繁出现的诸如DDL、共享库、运行时绑定等新技术的使用，把优化推迟到程序运行时可以解决这些问题，DynamoRIO因此而生。而动态插桩是实现动态优化的基础手段。</p>
<p>DynamoRIO的论文写于2002年。</p>
<h4 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h4><p><img src="https://raw.githubusercontent.com/hxygmy/pgo/main/img/202405210826617.png" alt="image-20240512174233072"></p>
<ol>
<li><p>在开始运作时，内存空间中由DynamoRIO的指令开始执行，找到目标应用程序的指令的地址，通过Basic Block Builder对该指令进行切分，并把之前的不包含跳转或返回指令的片段划分为一个基本块，复制到Code Cache中。</p>
<p>基本块（Basic Block）指一段指令序列，该序列中有且仅有最后一个指令是跳转或返回指令，在其之前的所有指令都必然是顺序执行的无分支指令。</p>
<p>在每个跳转或返回指令的位置作为最后一条指令进行切分，可以方便地理清控制流。</p>
</li>
<li><p>通过Context Switch把控制权交给应用程序。Context Switch是一个交换控制权的机制，它主要做的事有暂存程序运行状态，如寄存器的值。</p>
<blockquote>
<p>Our context switch to and from the fragment cache are arranged such that there is no persistent state kept on the dstack, allowing us to start with a clean slate on exiting the cache. This eliminates the need to protect our dstack from inadvertent or malicious writes. We do not bother to save any DynamoRIO state, even the eflags. </p>
</blockquote>
<p>实际上 Context Switch 并不会保存DynamoRIO的状态，以防止恶意或无意写入。</p>
</li>
</ol>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">⭐提出问题：</span><br><span class="line"><span class="built_in">Context</span> <span class="built_in">Switch</span>究竟都干了什么？控制权转移应该如何理解？</span><br><span class="line">为什么可以不保存<span class="variable">DynamoRIO</span>的状态呢？</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">解决思路：</span><br><span class="line"><span class="built_in">Debug</span>一下看看。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">20240510</span>更新：</span><br><span class="line"><span class="built_in">Context</span> <span class="built_in">Switch</span>机制通过代码看起来是通过暂存<span class="variable">eflags</span>等寄存器来保存程序当前的运行状态以及各种变量的值，然后切换上下文。</span><br><span class="line">目前我的理解是是通过保存的内存地址和寄存器状态来“暂停”当前的程序，然后跳转到另一段指令的地址继续执行。</span><br><span class="line"></span><br><span class="line">不保存<span class="variable">DynamoRIO</span>的状态（甚至包括<span class="variable">eflags</span>）是因为<span class="variable">DynamoRIO</span>的指令在<span class="variable">Basic</span> <span class="built_in">Block</span> <span class="variable">Build</span>或<span class="built_in">Trace</span> <span class="built_in">Select</span>之后就结束了，在下次<span class="variable">DynamoRIO</span>取得控制权时，它应做的事是同样的。</span><br><span class="line">而<span class="built_in">Trace</span> <span class="variable">Build</span>在现在看来其实不需要<span class="built_in">Context</span> <span class="built_in">Switch</span>，因为在<span class="variable">Basic</span> <span class="built_in">Block</span>执行时，通过<span class="variable">Basic</span> <span class="built_in">Block</span>计数器机制来计算某个<span class="variable">Basic</span> <span class="built_in">Block</span>执行了多少次，如果超过某个阈值则作为<span class="built_in">Trace</span> <span class="built_in">Head</span>开始建立<span class="built_in">Trace</span>，这个逻辑在<span class="variable">stub</span>中实现，并不需要通过<span class="built_in">Context</span> <span class="built_in">Switch</span>切换回<span class="variable">DynamoRIO</span>。</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>执行Basic Block Cache中的指令，如果最后一句指令是直接跳转，即只有一种情况的单分支跳转，且跳转的地址已经在Basic Block Cache中了，那么就直接继续执行，否则通过Context Switch存储当前应用程序的状态并切换到DynamoRIO中执行指令复制的操作。</p>
</li>
<li><p>如果Basic Block Cache中最后的跳转语句是多分支的，即跳转的地址可能有多个的，就使用一个Hash table来查找地址映射，这个过程称为间接分支查找。这个Hash table的建立时，是以目标程序的内存地址为键，Code Cache中的地址为值的。</p>
<p>间接分支查找的过程中，如果有经常按照某个特定分支继续执行时，会把下一个基本块和现在执行的代码块直接连接在一起，称为Trace。在一个基本块完成时仍然会由最后一个跳转或返回指令进行寻址，如果符合Trace Cache，就留在Trace Cache中继续执行，否则再进行完整的查找。</p>
<p>这种设计带来的性能提升可以在很大程度上弥补建立这种结构带来的开销，且通常优于原程序的速度。</p>
</li>
</ol>
<h4 id="DynamoRIO-Client"><a href="#DynamoRIO-Client" class="headerlink" title="DynamoRIO Client"></a>DynamoRIO Client</h4><h5 id="指令的表示级别"><a href="#指令的表示级别" class="headerlink" title="指令的表示级别"></a>指令的表示级别</h5><p>指Code Cache中程序的指令的详细程度</p>
<ul>
<li><p>Level 0，直接保存指令序列，不进行任何拆分</p>
</li>
<li><p>Level 1，拆分了每一条指令</p>
</li>
<li><p>Level 2，增记了每条指令对应的操作（opcode）以及eflags</p>
</li>
<li><p>Level 3，增记操作数（operands）</p>
</li>
<li><p>Level 4，对指令进行了重新编码以适应优化或重组需求</p>
</li>
</ul>
<p>一个Basic Block中缓存的指令可以包含不同的指令级别。比如，只有最后一条指令是跳转或返回指令，则只对最后一条指令应用level 3指令级别，之前的指令仅保存指令序列，即level 0指令级别。</p>
<p>DynamoRIO提供了一个叫做InstrList的数据结构，简单来理解就是一个List里面有多个Instr，而Instr存储机器码序列。</p>
<h5 id="API"><a href="#API" class="headerlink" title="API"></a>API</h5><p>DynamoRIO 程序本体运行时会在每个线程的私有内存空间中创建<code>多个 API</code>(例程)，并在 thread-local slots 来存储寄存器的值。此外，它还提供了一个共享的空间供其他 DynamoRIO 运行的线程使用，并在 Instr 数据结构中提供了一个用于注释的字段。</p>
<p>Basic Block或Trace在运行结束时，DynamoRIO提供了一个叫做custom exit stubs的机制，用于在Context Switch之前保存退出的位置，且在每个stub中可以附加一些指令或代码，以此来实现插桩。</p>
<p>API中还包含一些识别处理器的功能用于执行特定体系下的优化。</p>
<blockquote>
<p>thread-local slots : 线程私有槽，用于在本线程中保存一些数据，在DynamoRIO中主要是寄存器的值。</p>
<p>在源代码的<code>core/fcache.c</code>中定义了代码缓存的核心逻辑，其实就是在线程所独占的内存中开放的一个可以存储数据的空间。</p>
<p><strong>此处问题</strong>：这是不是DynamoRIO的一个特殊机制？在别的多线程程序中，应该也有类似的机制来避免多个线程争抢register。</p>
<p>custom exit stubs：该Stub给了插桩可能性。此处对应源代码中<code>core/fragment.h</code>中定义的<code>struct _fragment_t</code>数据结构，此结构是<code>basic block</code>和<code>trace</code>的数据结构。使用<code>FRAGMENT_EXIT_STUBS()</code>访问</p>
</blockquote>
<h5 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h5><p>Client可以实现一些常用功能</p>
<p><img src="https://raw.githubusercontent.com/hxygmy/pgo/main/img/202405210826777.png" alt="image-20240512174337784"></p>
<p>这里的<code>*context</code>是一个不应被修改的参数，是一个指向当前线程的context的指针。<code>tag</code>是用于根据被插桩程序唯一标识<code>fragment</code></p>
<p>Client还提供了<strong>自适应优化</strong>的接口，即</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InstrList* <span class="title function_">dr_decode_fragment</span><span class="params">(<span class="type">void</span> *context, app_pc tag)</span>;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">dr_replace_fragment</span><span class="params">(<span class="type">void</span> *context, app_pc tag, InstrList *il)</span>;</span><br></pre></td></tr></table></figure>

<p>这两个接口的作用是对已经缓存的Trace进行修改，该修改是热插拔的。</p>
<p>还有一个接口是<strong>自定义Trace头</strong>的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dr_mark_trace_head</span><span class="params">(<span class="type">void</span> *context, app_pc tag)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="实践-基本块的平均大小（官方示例添加注释）"><a href="#实践-基本块的平均大小（官方示例添加注释）" class="headerlink" title="实践-基本块的平均大小（官方示例添加注释）"></a>实践-基本块的平均大小（官方示例添加注释）</h4><p>在DynamoRIO Client的测试中，有一种在用调试器去调试调试器的感觉。</p>
<ol>
<li><p>main函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dr_api.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">DR_EXPORT <span class="type">void</span> <span class="title function_">dr_client_main</span><span class="params">(<span class="type">client_id_t</span> id, <span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注册callback function，callback function是一个“让API调用我自己”的函数，用作DynamoRIO调用Client中自己实现的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">event_exit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">dr_emit_flags_t</span> <span class="title function_">event_basic_block</span><span class="params">(<span class="type">void</span> *drcontext, <span class="type">void</span> *tag, <span class="type">instrlist_t</span> *bb,<span class="type">bool</span> for_trace, <span class="type">bool</span> translating)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册</span></span><br><span class="line">DR_EXPORT <span class="type">void</span> <span class="title function_">dr_client_main</span><span class="params">(<span class="type">client_id_t</span> id, <span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注册退出函数</span></span><br><span class="line">    dr_register_exit_event(event_exit);</span><br><span class="line">    <span class="comment">// 注册 basic block 级别的回调函数，这里用作添加插桩代码</span></span><br><span class="line">    dr_register_bb_event(event_basic_block);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现todo</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>实现回调函数，以下是全部代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dr_api.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPLAY_STRING(msg) dr_messagebox(msg)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基本块计数、指令计数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bb_counts</span> &#123;</span></span><br><span class="line">    uint64 blocks;</span><br><span class="line">    uint64 total_size;</span><br><span class="line">&#125; bb_counts;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量，用作计数</span></span><br><span class="line"><span class="type">static</span> bb_counts counts_as_built;</span><br><span class="line"><span class="comment">// 全局变量，锁</span></span><br><span class="line"><span class="type">void</span> *as_built_lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程退出回调函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">event_exit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 基本块回调函数</span></span><br><span class="line"><span class="type">static</span> <span class="type">dr_emit_flags_t</span> <span class="title function_">event_basic_block</span><span class="params">(<span class="type">void</span> *drcontext, <span class="type">void</span> *tag, <span class="type">instrlist_t</span> *bb,<span class="type">bool</span> for_trace, <span class="type">bool</span> translating)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DynamoRIO Client的 main 函数</span></span><br><span class="line">DR_EXPORT <span class="type">void</span> <span class="title function_">dr_client_main</span><span class="params">(<span class="type">client_id_t</span> id, <span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 注册退出函数</span></span><br><span class="line">    dr_register_exit_event(event_exit);</span><br><span class="line">    <span class="comment">// 注册 basic block 级别的回调函数，这里用作添加插桩代码</span></span><br><span class="line">    dr_register_bb_event(event_basic_block);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建锁</span></span><br><span class="line">    as_built_lock = dr_mutex_create();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在运行结束时显示结果</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">event_exit</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">char</span> msg[<span class="number">512</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    len = <span class="built_in">snprintf</span>(msg, <span class="keyword">sizeof</span>(msg) / <span class="keyword">sizeof</span>(msg[<span class="number">0</span>]),</span><br><span class="line">                    <span class="string">&quot;Number of basic blocks built : %&quot;</span>UINT64_FORMAT_CODE<span class="string">&quot;\n&quot;</span></span><br><span class="line">                    <span class="string">&quot;     Average size            : %5.2lf instructions\n&quot;</span>,</span><br><span class="line">                    counts_as_built.blocks,</span><br><span class="line">                    counts_as_built.total_size / (<span class="type">double</span>)counts_as_built.blocks);</span><br><span class="line">    DR_ASSERT(len &gt; <span class="number">0</span>);</span><br><span class="line">    msg[<span class="keyword">sizeof</span>(msg)/<span class="keyword">sizeof</span>(msg[<span class="number">0</span>])<span class="number">-1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    DISPLAY_STRING(msg);</span><br><span class="line">    <span class="comment">// 解除锁</span></span><br><span class="line">    dr_mutex_destroy(as_built_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">dr_emit_flags_t</span> <span class="title function_">event_basic_block</span><span class="params">(<span class="type">void</span> *drcontext, <span class="type">void</span> *tag, <span class="type">instrlist_t</span> *bb, <span class="type">bool</span> for_trace, <span class="type">bool</span> translating)</span> &#123;</span><br><span class="line">    uint num_instructions = <span class="number">0</span>;</span><br><span class="line">    <span class="type">instr_t</span> *instr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// instrList用于存储指令，每个instr都是一部分指令，这里可以计数指令的数量</span></span><br><span class="line">    <span class="keyword">for</span> (instr = instrlist_first(bb); instr != <span class="literal">NULL</span>; instr = instr_get_next(instr)) &#123;</span><br><span class="line">        num_instructions++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dr_mutex_lock(as_built_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在自定义的结构中自增，用以基本块计数</span></span><br><span class="line">    counts_as_built.blocks++;</span><br><span class="line">    counts_as_built.total_size += num_instructions;</span><br><span class="line">    dr_mutex_unlock(as_built_lock);</span><br><span class="line">    <span class="keyword">return</span> DR_EMIT_DEFAULT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="实践-自写递归函数调用栈深"><a href="#实践-自写递归函数调用栈深" class="headerlink" title="实践-自写递归函数调用栈深"></a>实践-自写递归函数调用栈深</h4><p>自写部分使用<code>drmgr</code></p>
<p>测试用程序，本程序是一个求解数独的算法，使用了回溯法，使用DynamoRIO Client插桩的目的是查看递归的函数调用的深度</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Created by hexiaoyu </span></span><br><span class="line"><span class="comment"> * on 2023/3/16 0:29</span></span><br><span class="line"><span class="comment"> * https://leetcode.cn/problems/sudoku-solver/</span></span><br><span class="line"><span class="comment"> * hard</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;vector&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">yeahYouCanPos</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; &amp;board, <span class="type">int</span> row, <span class="type">int</span> col, <span class="type">char</span> num)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ssk</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; &amp;board)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solveSudoku</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; board = &#123;</span><br><span class="line">             &#123;<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>&#125;</span><br><span class="line">            ,&#123;<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>&#125;</span><br><span class="line">            ,&#123;<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;.&#x27;</span>&#125;</span><br><span class="line">            ,&#123;<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;3&#x27;</span>&#125;</span><br><span class="line">            ,&#123;<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;1&#x27;</span>&#125;</span><br><span class="line">            ,&#123;<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;6&#x27;</span>&#125;</span><br><span class="line">            ,&#123;<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;.&#x27;</span>&#125;</span><br><span class="line">            ,&#123;<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;5&#x27;</span>&#125;</span><br><span class="line">            ,&#123;<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;9&#x27;</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">solveSudoku</span>(board);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++j) &#123;</span><br><span class="line">            cout &lt;&lt; board[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solveSudoku</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">ssk</span>(board);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ssk</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; &amp;board)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">char</span> k = <span class="string">&#x27;1&#x27;</span>; k &lt;= <span class="string">&#x27;9&#x27;</span>; k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">yeahYouCanPos</span>(board, i, j, k))&#123;</span><br><span class="line">                        board[i][j] = k;</span><br><span class="line">                        <span class="keyword">if</span>(<span class="built_in">ssk</span>(board)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        board[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">yeahYouCanPos</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; &amp;board, <span class="type">int</span> row, <span class="type">int</span> col, <span class="type">char</span> num)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 行列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(board[row][i] == num) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(board[i][col] == num) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 九宫格</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = (row / <span class="number">3</span>) * <span class="number">3</span>; i &lt; (row / <span class="number">3</span>) * <span class="number">3</span> + <span class="number">3</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = (col / <span class="number">3</span>) * <span class="number">3</span>; j &lt; (col / <span class="number">3</span>) * <span class="number">3</span> + <span class="number">3</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][j] == num) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">⭐提出问题：</span><br><span class="line">由于在入口点处`call_switch_stack`就有大量的汇编代码，我目前看着非常吃力。</span><br><span class="line">我不知道汇编语言对于后续学习的重要性如何，应该如何学习。</span><br><span class="line"></span><br><span class="line">解决思路：</span><br><span class="line">问老师。</span><br></pre></td></tr></table></figure>

<ol>
<li><p><code>CMakeLists.txt</code></p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.10)</span><br><span class="line">project(myclient)</span><br><span class="line"></span><br><span class="line"># 设置DynamoRIO的安装路径</span><br><span class="line"># set(DynamoRIO_DIR D:/Tools/DynamoRIO-10.0.0/cmake)</span><br><span class="line">set(DynamoRIO_DIR /root/app/dynamorio/cmake)</span><br><span class="line"></span><br><span class="line">add_library(myclient SHARED myclient.c)</span><br><span class="line"></span><br><span class="line"># 查找DynamoRIO的包</span><br><span class="line">find_package(DynamoRIO REQUIRED)</span><br><span class="line"></span><br><span class="line"># 包含DynamoRIO的头文件</span><br><span class="line">include_directories($&#123;DynamoRIO_INCLUDE_DIRS&#125;)</span><br><span class="line"></span><br><span class="line"># 设置项目源文件</span><br><span class="line">set(SOURCES myclient.c)</span><br><span class="line"></span><br><span class="line"># 生成可执行文件</span><br><span class="line">#add_executable(myclient $&#123;SOURCES&#125;)</span><br><span class="line"></span><br><span class="line"># 链接DynamoRIO的库文件</span><br><span class="line">target_link_libraries(myclient $&#123;DynamoRIO_LIBRARIES&#125;)</span><br><span class="line"></span><br><span class="line">use_DynamoRIO_extension(myclient drmgr)</span><br><span class="line"></span><br><span class="line">use_DynamoRIO_extension(myclient drwrap)</span><br><span class="line"></span><br><span class="line">configure_DynamoRIO_client(myclient)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>myclient.c</code></p>
<p>DynamoRIO使用形如<code>dr_insert_call_instrumentation</code>之类的方法来实现使用回调函数插桩，诸如此类的函数还有<code>dr_insert_mbr_instrumentation``dr_insert_cbr_instrumentation</code>，在它们内部都调用了<code>dr_insert_clean_call</code>，这个函数需要传入当前分支指令的地址和目标分支指令的地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里是源码，用于讲解，不是我的Client。</span></span><br><span class="line"><span class="comment">// 这个Clean call其实是为了实现Transparency</span></span><br><span class="line"><span class="comment">// 在这个函数中可以切换到 clean 的内存堆栈，并选择性地保存寄存器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dr_insert_clean_call_ex_varg</span><span class="params">(<span class="type">void</span> *drcontext, <span class="type">instrlist_t</span> *ilist, <span class="type">instr_t</span> *where,</span></span><br><span class="line"><span class="params">                             <span class="type">void</span> *callee, <span class="type">dr_cleancall_save_t</span> save_flags, uint num_args,</span></span><br><span class="line"><span class="params">                             <span class="type">opnd_t</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// [...] 这里有一堆看着头大的汇编代码，我决定暂时放弃研究它</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;dr_api.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;drmgr.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;drwrap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> recursion_depth = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> max_recursion_depth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插桩函数 - 在进入递归函数时增加递归深度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">enter_recursive_function</span><span class="params">(<span class="type">void</span> *drcontext, <span class="type">void</span> **tag)</span> &#123;</span><br><span class="line">    recursion_depth++;</span><br><span class="line">    dr_printf(<span class="string">&quot;当前调用深度为 %d&quot;</span> <span class="string">&quot;\n&quot;</span>, recursion_depth);</span><br><span class="line">    <span class="keyword">if</span> (max_recursion_depth &lt; recursion_depth) &#123;</span><br><span class="line">        max_recursion_depth = recursion_depth;</span><br><span class="line">        dr_printf(<span class="string">&quot;当前最大调用深度为 %d&quot;</span> <span class="string">&quot;\n&quot;</span>, max_recursion_depth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插桩函数 - 在离开递归函数时减少递归深度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit_recursive_function</span><span class="params">(<span class="type">void</span> *drcontext, <span class="type">void</span> *tag)</span> &#123;</span><br><span class="line">    recursion_depth--;</span><br><span class="line">    dr_printf(<span class="string">&quot;当前调用深度为 %d&quot;</span> <span class="string">&quot;\n&quot;</span>, recursion_depth);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">module_load_event</span><span class="params">(<span class="type">void</span> *drcontext, <span class="type">const</span> <span class="type">module_data_t</span> *mod, <span class="type">bool</span> loaded)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 返回给定函数的入口点</span></span><br><span class="line">    app_pc towrap = (app_pc)dr_get_proc_address(mod-&gt;handle, <span class="string">&quot;_Z3sskRSt6vectorIS_IcSaIcEESaIS1_EE&quot;</span>);</span><br><span class="line"><span class="comment">//    dr_printf(&quot;come in 入口点 _Z3sskRSt6vectorIS_IcSaIcEESaIS1_EE &quot; PFX &quot; \n&quot;, towrap);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (towrap != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 在函数执行前插桩</span></span><br><span class="line">        <span class="type">bool</span> ok = drwrap_wrap(towrap, enter_recursive_function, exit_recursive_function);</span><br><span class="line">        <span class="keyword">if</span> (!ok) &#123;</span><br><span class="line">            DR_ASSERT(ok);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">event_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    dr_printf(<span class="string">&quot;最大调用深度为 %d&quot;</span>  <span class="string">&quot;\n&quot;</span>, max_recursion_depth);</span><br><span class="line">    drwrap_exit();</span><br><span class="line">    drmgr_exit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DR_EXPORT <span class="type">void</span> <span class="title function_">dr_init</span><span class="params">(<span class="type">client_id_t</span> id)</span></span><br><span class="line">&#123;</span><br><span class="line">    drmgr_init();</span><br><span class="line">    drwrap_init();</span><br><span class="line">    dr_register_exit_event(event_exit);</span><br><span class="line"></span><br><span class="line">    drmgr_register_module_load_event(module_load_event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Windows下，直接<code>cmake ..</code>是不可以的，要用<code>cmake .. -G &quot;Unix Makefiles&quot;</code>才会生成熟悉的带有Makefile输出。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试shell</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">准备一个cpp，这里是随便找的一个计算数独的算法</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入写了上面的文件的文件夹，把cpp文件放进去</span></span><br><span class="line">cd ~/code/dynamorio_client</span><br><span class="line">   </span><br><span class="line">mkdir build</span><br><span class="line">cd build</span><br><span class="line">   </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译，要拿到符号</span></span><br><span class="line">g++ -rdynamic 00920037.cpp -o targ</span><br><span class="line">nm -D targ | grep ssk</span><br><span class="line">   </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编译</span></span><br><span class="line">cmake ..</span><br><span class="line">make</span><br><span class="line">   </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行 要先设置好DYNAMORIO_HOME或者给一个路径</span></span><br><span class="line">drrun -debug -root $DYNAMORIO_HOME -c ./libmyclient.so -- ./targ</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">要了老命了搞了得有10个小时</span>   </span><br></pre></td></tr></table></figure></li>
</ol>
<p>​	结果</p>
<p>   <img src="https://raw.githubusercontent.com/hxygmy/pgo/main/img/202405210826115.png" alt="image-20240517183535176"></p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">心得<span class="number">20240504</span>:</span><br><span class="line"></span><br><span class="line">实际上论文给的原理非常详细，以我现在的水平看起来还是比较困难的。但是看到现在，基本上也祛魅了底层系统的神秘性，实际上并不神秘。要形容的话，应该是精密。</span><br><span class="line"></span><br><span class="line">以我目前的知识储备，对CPU指令集并非很熟悉，这些内容应该属于编译原理或计算机组成原理，应加强学习。内功熟练外功才能举重若轻且举一反三。</span><br></pre></td></tr></table></figure>

<h3 id="五、Intel-Pin"><a href="#五、Intel-Pin" class="headerlink" title="五、Intel Pin"></a>五、Intel Pin</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>Pin 是一个由 Intel 开发的非开源动态二进制插桩工具软件，只支持Intel平台。</p>
<p>Pin 首个版本发布于2004年7月，论文发布于2005年。</p>
<h4 id="架构设计-1"><a href="#架构设计-1" class="headerlink" title="架构设计"></a>架构设计</h4><p><img src="https://raw.githubusercontent.com/hxygmy/pgo/main/img/202405210826849.png" alt="image-20240513170956493"></p>
<ol>
<li>Pintool 通过 Instrumentation API 调用虚拟机</li>
<li>JIT即时编译目标程序（此时可以插桩），且通常是从一个ISA<strong>翻译</strong>到相同的ISA，编译后的代码通过Dispatcher存储在Code Cache中。</li>
<li>由Dispacher启动目标程序。Code Cache和VM之间涉及到保存和恢复应用程序的寄存器状态（Context Switch）</li>
<li>Emulation Unit的主要作用是针对不同的运行环境（操作系统、指令集）来以不同的策略对代码进行编译，以一个虚拟机或Docker的角度来理解即可。</li>
</ol>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">⭐提出问题：</span><br><span class="line">在PIN已经安装在计算机上之后，应该已经确定了PIN的运行环境，那只要在PIN的安装程序中来确定运行环境就可以了，为什么在PIN的程序中还使用了Emulation <span class="keyword">Unit</span>这样的组件来保证在不同的运行环境下以不同的编译方式来编译代码？</span><br><span class="line"></span><br><span class="line">解决思路：</span><br><span class="line">目前没什么思路，可以通过DynamoRIO对比学习一下吧。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">20240512</span>更新：</span><br><span class="line">Emulation <span class="keyword">Unit</span>可能针对的不是CPU的ISA而是程序的。有的程序对不同的指令集有兼容性。但是这只是我的猜测，根据查到的资料不能确定是不是这样。</span><br><span class="line">在DynamoRIO中，Basic <span class="keyword">Block</span>的建立过程可能涉及到二进制翻译（DBT），在这个过程中理论上可以在任意位置进行插桩，而实现二进制翻译显然需要类似于Emulation <span class="keyword">Unit</span>的模块来支持。</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>Code Cache存储了目标程序的指令以及可能存在的插桩指令。</li>
<li>总结一下，PIN是一个引擎，负责即时编译、插桩Application；Application是待分析的目标应用程序；Pintool是通过Instrumentation API来实现的自定义插桩规则。这三个不同的部分会采用直接保存三份glibc的方式来避免发生代码重入的冲突。</li>
</ol>
<h4 id="数据流转"><a href="#数据流转" class="headerlink" title="数据流转"></a>数据流转</h4><ol>
<li><p>PIN通过<code>UNIX ptrace API</code>来注入目标应用程序中，该方式可以把PIN的二进制文件<code>寄生</code>到目标应用程序上去</p>
<blockquote>
<p>DynamoRIO使用的是<code>LD PRELOAD</code>，PIN的改进点在于，<code>LD PRELOAD</code>不处理静态连接、加载额外的共享库可能会把这些共享库的内存地址堆得很高、<code>LD PRELOAD</code>需要加载一部分之后才能执行插桩程序而PIN在第一条指令就可以插桩（PIN作者认为这是一个<code>LD PRELOAD</code>的bug）</p>
</blockquote>
</li>
<li><p>PIN把Pintool加载到内存中并启动，Pintool加载完成后要求PIN启动Application</p>
</li>
<li><p>PIN开始通过JIT编译目标应用程序，Application的原始代码不会被执行，一般情况下，PIN直接从一个ISA编译到同一个ISA。</p>
</li>
<li><p>PIN编译应用程序时按照代码块来分步执行，遇到以下三种情况之一的就会暂停编译</p>
<ol>
<li>无分支跳转</li>
<li>有分支跳转</li>
<li>代码缓存中已经有了该路径的建立</li>
</ol>
</li>
<li><p>如果有代码块的执行路径经常被执行，则链接它们成为<code>Trace</code>。</p>
<blockquote>
<p>基本思路和DynamoRIO是一致的，显然借鉴了DynamoRIO的思路。但在很多细节处有不同，因为PIN是后来者，所以进行了一些改进。</p>
<ol>
<li><p>在Trace的建立过程中，DynamoRIO是在Translation的过程中一次性建立好，所以不能在Trace中添加新的预测轨迹。而PIN可以在Trace的链中把新的基本块添加进来。所以，DynamoRIO在Trace未命中时选择通过Indirect branch lookup搜索哈希表，而PIN可以在该Trace中再搜索。</p>
</li>
<li><p>DynamoRIO在Indirect branch lookup中使用的是global hash table，而PIN使用了local hash table。这里的local指的是，每一个Indirect branch lookup，而不是线程本地。</p>
</li>
<li><p>对于某些经常被调用的函数，在内存中创建多个副本，这样每个副本就可以成为某个Trace的专属调用链路的一部分，从而减少间接跳转。</p>
<p>这里我认为这样的方式不是在任何情况下都是有效的。</p>
</li>
</ol>
</blockquote>
</li>
<li><p>如果代码块已经执行结束，则有可能出现间接跳转，并需要通过PIN重新编译新的代码块到Code Cache中。</p>
<p>这里就涉及到了寄存器暂存的问题。这里也是PIN相对于DynamoRIO的不同点。</p>
<p><strong>寄存器重分配</strong>：在JIT中经常需要额外的寄存器，Pintool和Application需要占用的寄存器经常发生冲突，尤其JIT编译（翻译）包含插桩的代码时。PIN使用了<code>Linear-scan register allocation</code>这个寄存器重分配算法，指的是通过一次遍历，来确定每个变量需要多少个寄存器，并且把寄存器分配给变量。PIN还支持跨函数的寄存器分配。这里也涉及到寄存器状态分析，PIN可以在不溢出（Spilling）寄存器的情况下使用dead register。</p>
<p>寄存器重分配在DynamoRIO中是没有的，根据看到的代码，DynamoRIO在Context Switch时，会把所有的寄存器的值都写入thread-local slots中。</p>
<p><strong>寄存器溢出（Register spilling）</strong>：此部分和DynamoRIO类似。PIN把某个物理寄存器用作存放指向某个线程的虚拟寄存器的指针，因为线程的虚拟寄存器必须是thread-local的，所以物理寄存器的指针用作动态存储当前线程的虚拟寄存器位置。</p>
</li>
</ol>
<h4 id="Pintool"><a href="#Pintool" class="headerlink" title="Pintool"></a>Pintool</h4><p><strong>插桩级别</strong></p>
<ol>
<li><p><code>INS_AddInstrumentFunction</code>指令级插桩</p>
</li>
<li><p><code>TRACE_AddInstrumentFunction</code>Trace插桩，实际上也是基本块插桩</p>
</li>
<li><p><code>IMG_AddInstrumentFunction</code>镜像插桩，需要提前<code>PIN_InitSymbols()</code></p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">⭐提出问题：</span><br><span class="line">不是很懂什么叫IMG，API doc中的解释是</span><br><span class="line">An IMG represents all the data structures corresponding to a binary (executable). </span><br><span class="line">https://software.intel.com/sites/landingpage/pintool/docs/98830/Pin/doc/html/group__IMG.html</span><br><span class="line">查阅了一番资料之后没有更加详细的解释，目前我自己的理解是，IMG是代表了一个二进制的可执行文件本身。IMG级别的插桩的意思是，在一个给定的二进制可执行文件中，通过`PIN_InitSymbols()`能找到的符号代表的位置都可以插桩，比如数据结构、函数、变量。</span><br><span class="line">但是我不敢确定我的理解是不是正确。</span><br><span class="line"></span><br><span class="line">解决思路：</span><br><span class="line">问老师。</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>RTN_AddInstrumentFunction</code>例程插桩（函数级插桩），需要提前<code>PIN_InitSymbols()</code></p>
</li>
</ol>
<p><strong>代码模型</strong></p>
<p>直接上例子比较直观</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pin.H&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cerr;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::ios;</span><br><span class="line"><span class="keyword">using</span> std::ofstream;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 本例来源于 source/tools/ManualExamples/ins/inscount0.cpp 为了方便理解更改了函数的顺序*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 初始化PIN，还返回了函数用于提示，不返回也可以</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">PIN_Init</span>(argc, argv)) <span class="keyword">return</span> <span class="built_in">Usage</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 注册输出文件函数KnobOutputFile，该函数的声明为了方便理解没有放在上面</span></span><br><span class="line">    OutFile.<span class="built_in">open</span>(KnobOutputFile.<span class="built_in">Value</span>().<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 插桩级别，注册一个Instruction函数</span></span><br><span class="line">    <span class="built_in">INS_AddInstrumentFunction</span>(Instruction, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 指定退出函数</span></span><br><span class="line">    <span class="built_in">PIN_AddFiniFunction</span>(Fini, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 启动</span></span><br><span class="line">    <span class="built_in">PIN_StartProgram</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.1 退出函数</span></span><br><span class="line"><span class="function">VOID <span class="title">Fini</span><span class="params">(INT32 code, VOID* v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 推出前写入文件</span></span><br><span class="line">    OutFile.<span class="built_in">setf</span>(ios::showbase);</span><br><span class="line">    OutFile &lt;&lt; <span class="string">&quot;Count &quot;</span> &lt;&lt; icount &lt;&lt; endl;</span><br><span class="line">    OutFile.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.1 声明输出函数</span></span><br><span class="line"><span class="function">KNOB&lt; string &gt; <span class="title">KnobOutputFile</span><span class="params">(KNOB_MODE_WRITEONCE, <span class="string">&quot;pintool&quot;</span>, <span class="string">&quot;o&quot;</span>, <span class="string">&quot;inscount.out&quot;</span>, <span class="string">&quot;specify output file name&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.1 在每条指令前插入对 docount 的调用，不传递参数，INS_InsertCall函数是一个主要的插桩函数，在各个插桩级别通用</span></span><br><span class="line"><span class="function">VOID <span class="title">Instruction</span><span class="params">(INS ins, VOID* v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 注册了一个docount函数用于计数</span></span><br><span class="line">    <span class="built_in">INS_InsertCall</span>(ins, IPOINT_BEFORE, (AFUNPTR)docount, IARG_END);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.1.1 计数函数</span></span><br><span class="line"><span class="type">static</span> UINT64 icount = <span class="number">0</span>;</span><br><span class="line"><span class="function">VOID <span class="title">docount</span><span class="params">()</span> </span>&#123; icount++; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.1 初始化时返回的函数，其实就是提示一下</span></span><br><span class="line"><span class="function">INT32 <span class="title">Usage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;This tool counts the number of dynamic instructions executed&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cerr &lt;&lt; endl &lt;&lt; KNOB_BASE::<span class="built_in">StringKnobSummary</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="六、DynamoRIO-vs-Pin"><a href="#六、DynamoRIO-vs-Pin" class="headerlink" title="六、DynamoRIO vs Pin"></a>六、DynamoRIO vs Pin</h3><p>DynamoRIO是一个开源的，以优化为主要目的，以插桩为基本手段的系统优化工具，由来自MIT、VMWare的团队开发。</p>
<p>Pin是一个闭源的，仅支持Intel平台的免费插桩工具。</p>
<p>在PIN的测试中，在不插桩的情况下，DynamoRIO的统计基本块速度比PIN快12%。由于PIN寄存器重分配、动态Trace建立、local hash table、重用函数副本的机制下，在插桩代码的效率对比上，PIN比DynamoRIO快了很多。</p>
<blockquote>
<p>When we consider the performance with instrumentation shown in Figure 7(b), Pin outperforms both DynamoRIO and Valgrind by a signiﬁcant margin: on average, Valgrind slows the application down by 8.3 times, DynamoRIO by 5.1 times, and Pin by 2.5 times.</p>
</blockquote>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">心得<span class="number">20240512</span></span><br><span class="line"></span><br><span class="line">总体来说，我要实现一个动态插桩工具，依然并非是一个简单的事，目前看起来PIN相对DynamoRIO要容易一些。</span><br><span class="line">但是对代码的研究感觉上收获最大的其实不是学会了一点插桩工具相关的使用方法，而是对这个沉下心来的过程有了一些体会。</span><br><span class="line"></span><br><span class="line">刨根问底真的是一件好事。学习就是刨根问底的过程。</span><br><span class="line">在真的深入研究之后，发现之前认为很烧脑、复杂的东西实际上也就这么回事。对全貌有了大致的理解之后，就逐渐祛魅了。</span><br><span class="line">看到成熟的工业级代码还是觉得有差距，但不再遥不可及了。</span><br><span class="line"></span><br><span class="line">另外Deadline是一个必要的机制。在支持自己学习的只有一个“我在变强”的信念时，其实是比较脆弱的。这点在忍受可能长达几个小时的<span class="keyword">debug</span>时尤其突出。</span><br><span class="line"></span><br><span class="line">像CMU15445的bustub一样，也许可以找一个手写编译器的项目继续进修一下。</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Paper/" rel="tag"># Paper</a>
              <a href="/tags/%E7%B3%BB%E7%BB%9F%E4%BC%98%E5%8C%96/" rel="tag"># 系统优化</a>
              <a href="/tags/Instrumentation/" rel="tag"># Instrumentation</a>
              <a href="/tags/DynamoRIO/" rel="tag"># DynamoRIO</a>
              <a href="/tags/Intel-Pin/" rel="tag"># Intel Pin</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/03/21/004-10MostRepresentativeProfessionalTermsinDatabaseSystems/" rel="prev" title="10 Most Representative Professional Terms in Database Systems">
      <i class="fa fa-chevron-left"></i> 10 Most Representative Professional Terms in Database Systems
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/05/21/006AssemblyFromScratch/" rel="next" title="汇编基础">
      汇编基础 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%8F%92%E6%A1%A9"><span class="nav-number">1.</span> <span class="nav-text">一、什么是插桩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%8F%92%E6%A1%A9"><span class="nav-number">2.</span> <span class="nav-text">二、为什么需要插桩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E6%8F%92%E6%A1%A9%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">3.</span> <span class="nav-text">三、插桩的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%8F%92%E6%A1%A9%E5%92%8C%E5%8A%A8%E6%80%81%E6%8F%92%E6%A1%A9%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">3.1.</span> <span class="nav-text">静态插桩和动态插桩的对比</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E3%80%81DynamoRIO"><span class="nav-number">4.</span> <span class="nav-text">四、DynamoRIO</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">4.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="nav-number">4.2.</span> <span class="nav-text">架构设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DynamoRIO-Client"><span class="nav-number">4.3.</span> <span class="nav-text">DynamoRIO Client</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8C%87%E4%BB%A4%E7%9A%84%E8%A1%A8%E7%A4%BA%E7%BA%A7%E5%88%AB"><span class="nav-number">4.3.1.</span> <span class="nav-text">指令的表示级别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#API"><span class="nav-number">4.3.2.</span> <span class="nav-text">API</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Client"><span class="nav-number">4.3.3.</span> <span class="nav-text">Client</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E8%B7%B5-%E5%9F%BA%E6%9C%AC%E5%9D%97%E7%9A%84%E5%B9%B3%E5%9D%87%E5%A4%A7%E5%B0%8F%EF%BC%88%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B%E6%B7%BB%E5%8A%A0%E6%B3%A8%E9%87%8A%EF%BC%89"><span class="nav-number">4.4.</span> <span class="nav-text">实践-基本块的平均大小（官方示例添加注释）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E8%B7%B5-%E8%87%AA%E5%86%99%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88%E6%B7%B1"><span class="nav-number">4.5.</span> <span class="nav-text">实践-自写递归函数调用栈深</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94%E3%80%81Intel-Pin"><span class="nav-number">5.</span> <span class="nav-text">五、Intel Pin</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="nav-number">5.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1-1"><span class="nav-number">5.2.</span> <span class="nav-text">架构设计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E8%BD%AC"><span class="nav-number">5.3.</span> <span class="nav-text">数据流转</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Pintool"><span class="nav-number">5.4.</span> <span class="nav-text">Pintool</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%AD%E3%80%81DynamoRIO-vs-Pin"><span class="nav-number">6.</span> <span class="nav-text">六、DynamoRIO vs Pin</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="何晓宇"
      src="/images/favicon.ico">
  <p class="site-author-name" itemprop="name">何晓宇</p>
  <div class="site-description" itemprop="description">技术博客，系统优化，编译器，指令集</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/hxygmy" title="Github → https:&#x2F;&#x2F;github.com&#x2F;hxygmy" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>Github</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:hexi.aoyu@163.com" title="E-Mail → mailto:hexi.aoyu@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">何晓宇</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">38k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:17</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>















  

  

  

</body>
</html>
